# 进程
一个是操作系统用来管理进程的内核对象。内核对象也是系统用来存放关于进程的统计
信息的地方。
另一个是地址空间，它包含所有可执行模块或 D L L模块的代码和数据。它还包含动态内
存分配的空间。如线程堆栈和堆分配空间。

## 时间片
操作系
统就要为每个线程安排一定的 C P U时间。它
通过以一种循环方式为线程提供时间片（称
为量程），造成一种假象，仿佛所有线程都是
同时运行的一样。如果计算机有多个CPU，那么操作系统就会使用复杂的算法来实现CPU上的负载平衡。

## 主线程
当创建一个进程时，系统会自动创建它的第一个线程，称为主线程。然后，该线程可以创
建其他的线程，而这些线程又能创建更多的线程。

## GUI与CUI应用程序
通过 链接》系统》子系统，我们可以设置当前应用程序是GUI应用程序还是CUI应用程序。/ S U B S Y S T E M : C O N S O L E是CUI应用程序，/ S U B S Y S T E M : W I N D O W S是GUI应用程序。如果该值指明这是个G U I应用程序，那么加载程序不创建控制台窗口，而只是加载应用程序。
一旦应用程序启动运行，操作系统就不再考虑应用程序拥有什么类型的用户界面，此时会根据应用程序运行，如果应用程序中有创建新的窗口，那么即使当前是CUI应用程序，新的窗口也会被创建。

## 入口点函数和运行期启动函数
入口点函数主要有以下4个：
![image](https://github.com/Sherlock2022/soul/raw/main/resource/%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0.png)。

但实际上操作系统实际上并不直接调用你编写的进入点函数。而是调用C/C++运行期启动函数，然后该启动函数再调用我们的入口函数；该函
数负责对C / C + +运行期库进行初始化，这样，就可以调用m a l l o c和f r e e之类的函数。它还能够确
保已经声明的任何全局对象和静态 C + +对象能够在代码执行以前正确地创建。

C/C++运行期启动函数主要对应以下4个，这四个运行期启动函数正好对应了4个入口点函数：
![image]()

当进入点函数返回时，启动函数便调用 C运行期的e x i t函数，将返回值（n M a i n R e t Va l）传
递给它。

E x i t函数负责下面的操作：
• 调用由_ o n e x i t函数的调用而注册的任何函数。
• 为所有全局的和静态的C + +类对象调用析构函数。
• 调用操作系统的E x i t P r o c e s s函数，将n M a i n R e t Va l传递给它。这使得该操作系统能够撤消
进程并设置它的e x i t代码。

现在将启动函数的功能归纳如下：
• 检索指向新进程的完整命令行的指针。
• 检索指向新进程的环境变量的指针。
• 对C / C + +运行期的全局变量进行初始化。如果包含了 S t d L i b . h文件，代码就能访问这些变
量。表4 - 1列出了这些变量。
• 对C运行期内存单元分配函数（m a l l o c和c a l l o c）和其他低层输入/输出例程使用的内存栈
进行初始化。
• 为所有全局和静态C + +类对象调用构造函数。

函数调用流程图如下：
![image]()

链接程序在链接可执行文件时会根据链接程序开关，判断当前是GUI还是CUI程序，然后寻找对应的C/C++运行期启动函数，如果启动函数不在，那么就会返回一条“未转换外部符号”的信息；
如果链接程序开关，与我们实现的入口点函数不匹配，那么就会看到一个链接程序错误消息；
如果我们没有设置链接程序开关，连接程序将根据源代码中实现的函数进行正确的操作。



## 进程的实例句柄
加载到进程地址空间的每个可执行文件或 D L L文件均被赋予一个独一无二的实例句柄。许多函数都需要该句柄，例如，若要从可执行文件的映象来加载图标资源的loadIcon函数，其第一个参数用于指明明哪个文件（可执行文件或D L L文件）包含你想加载的资源。
实际值是系统将可执行文件的映象加载到进程的地址空间时
使用的基本地址空间。
可执行文件的映像加载到的基地址是由链接程序决定的。不同的链接程序可以使用不同的默认基地址。Visual C++链接程序使用的默认基地址是 0 x 0 0 4 0 0 0 0 0.
下面的Ge t M o d u l e H a n d l e函数返回可执行文件或 D L L文件加载到进程的地址空间时所用的
句柄/基地址：
当调用该函数时，你传递一个以 0结尾的字符串，用于设定加载到调用进程的地址空间的
可执行文件或 D L L 文件的名字。如果系统找到了指定的可执行文件或 D L L 文件名，
G e t M o d u l e H a n d l e便返回该可执行文件或 D L L文件映象加载到的基地址。如果系统没有找到该
文件，则返回 N U L L。也可以调用 G e t M o d u l e H a n d l e，为 p s z M o d u l e参数传递 N U L L，
G e t M o d u l e H a n d l e返回调用的可执行文件的基地址。

*重点：Ge t M o d u l e H a n d l e*

进程的实例句柄真的就是可执行文件加载到地址空间时使用的基本地址空间吗？

## 进程的命令行
该命令行几乎永远不会是空的，至少用于创
建新进程的可执行文件的名字是命令行上的第一个标记。

当 C运行期的
启动代码开始运行的时候，它要检索进程的命令行，跳过可执行文件的名字，并将指向命令行
其余部分的指针传递给Wi n M a i n的p s z C m d L i n e参数。
也可以获得一个指向进程的完整命令行的指针，方法是调用 G e t C o m m a n d L i n e函数：

## 进程的错误模式
与每个进程相关联的是一组标志，用于告诉系统，进程对严重的错误应该如何作出反映，
这包括磁盘介质故障、未处理的异常情况、文件查找失败和数据没有对齐等。进程可以告诉系
统如何处理每一种错误。方法是调用S e t E r r o r M o d e函数：
子进程默认会继承父进程的错误标志，但是子进程可能本身并不知道，如果要防止该标志被继承，可以再createProcess中设置相关标志位。

## 进程的当前驱动器和目录
当不提供全路径名时，Wi n d o w s的各个函数在被调用时就会在当前驱动器的当前目录中查找文件和目录，可以通过GetCurrentDirectory或SetCurrentDirectory来设置进程的当前驱动器和目录。

## 系统版本
可以通过getVersionEx来获取当前系统版本。

## CreateProcess
可以用C r e a t e P r o c e s s函数创建一个进程：
当一个线程调用C r e a t e P r o c e s s时，系统就会创建一个进程内核对象，其初始使用计数是 1
然后，系统为新进程的主线程创建一个线程内核对象（其使用计数为 1）。
。通过执行 C / C + +运行期启动
代码，该主线程便开始运行，它最终调用 Wi n M a i n、w Wi n M a i n、m a i n或w m a i n函数。如果系
统成功地创建了新进程和主线程，C r e a t e P r o c e s s便返回T R U E。

返回True并不意味子进程被完全初始化了，如果一个dll没找到，子进程仍会终止运行，即使此时已经返回了true。

p s z A p p l i c a t i o n N a m e和p s z C o m m a n d L i n e参数分别用于设定新进程将要使用的可执行文件的
名字和传递给新进程的命令行字符串。
p s z A p p l i c a t i o n N a m e需要传一个非常量字符串，函数在执行过程中会修改，但是最终在函数返回时被复原。
可以使用p s z C o m m a n d L i n e参数设定一个完整的命令行，以便 C r e a t e P r o c e s s用来创建新进
程。当C r e a t e P r o c e s s分析p s z C o m m a n d L i n e字符串时，它将查看字符串中的第一个标记，并假
设该标记是想运行的可执行文件的名字。如果可执行文件的文件名没有扩展名，便假设它的扩
展名为. e x e。C r e a t e P r o c e s s也按下面的顺序搜索该可执行文件：
1) 包含调用进程的. e x e文件的目录。
2) 调用进程的当前目录。
3) Wi n d o w s的系统目录。
4) Wi n d o w s目录。
5) PAT H环境变量中列出的目录。
当然，如果文件名包含全路径，系统将使用全路径来查看可执行文件，并且不再搜索这些
目录。如果系统找到了可执行文件，那么它就创建一个新进程，并将可执行文件的代码和数据
映射到新进程的地址空间中。然后系统将调用 C / C + +运行期启动例程。正如前面我们讲过的那
样，C / C + +运行期启动例程要查看进程的命令行，并将地址作为 ( w ) Wi n M a i n的p s z C m d L i n e参
数传递给可执行文件的名字后面的第一个参数。
系统将在p s z A p p l i c a t i o n N a m e为空的情况下在命令行中查找可执行程序的路径，但是当p s z A p p l i c a t i o n N a m e不为空，且是绝对路径，并包含扩展名时，程序将根据该路径启动。
但是，即使在 p s z A p p l i c a t i o n N a m e参数中设定了文件名， C r e a t e P r o c e s s也会将
p s z C o m m a n d L i n e参数的内容作为它的命令行传递给新进程。

```
BOOL CreateProcess(
  LPCWSTR pszImageName, 
  LPCWSTR pszCmdLine,
  LPSECURITY_ATTRIBUTES psaProcess,  //设置进程对象的安全性
  LPSECURITY_ATTRIBUTES psaThread,  //设置主线程的对象安全性
  BOOL fInheritHandles, //是否允许创建的进程继承当前进程可以访问的内核对象
  DWORD fdwCreate,
  LPVOID pvEnvironment,
  LPWSTR pszCurDir,
  LPSTARTUPINFOW psiStartInfo,
  LPPROCESS_INFORMATION pProcInfo
);
```
安全性的继承：
A进程创建了进程B，psaProcess.bInheritHandles = true,psaThread.bInheritHandles = false,
如果A进程创建进程C。
如果此时fInheritHandles为false，那么C进程将无法访问B。
如果fInheritHandles为true，那么C进程将可以访问B进程，但是无法访问B进程的主线程。








