<!--
 * @version: 1.0
 * @Author: wdl
 * @Date: 2022-03-13 09:32:45
 * @Descripttion: 
-->

# 线程
## 线程的构成
线程也是由两个部分组成的：
• 一个是线程的内核对象，操作系统用它来对线程实施管理。内核对象也是系统用来存放
线程统计信息的地方。
• 另一个是线程堆栈，它用于维护线程在执行代码时需要的所有函数参数和局部变量（第
1 6章将进一步介绍系统如何管理线程堆栈）。

## 进程与线程的区别
进程是不活泼的。进程从来不执行任何东西，它只是线程的容器。
进程使用的系统资源比线程多得多，原因是它需要更多的地址空间。为进程创
建一个虚拟地址空间需要许多系统资源。由于. e x e和. d l l文件要加载到一个地址空间，因此也需要文件资源。
而线程使用的系统资源
要少得多。实际上，线程只有一个内核对象和一个堆栈，保留的记录很少，因此需要很少的内
存。

## 线程内核对象的安全计数
线程终止运行，该堆栈的内存被释放，同时，线程的内核对象的使用计数被递减。如果
使用计数降为0，线程的内核对象就被撤消。与进程内核对象的情况相同，线程内核对象的寿命
至少可以达到它们相关联的线程那样长，不过，该对象的寿命可以远远超过线程本身的寿命。

线程函数（实际上是你的所有函数）应该尽可能使用函数参数和局部变量。当使用静态
变量和全局变量时，多个线程可以同时访问这些变量，这可能破坏变量的内容。然而，
参数和局部变量是在线程堆栈中创建的，因此它们不太可能被另一个线程破坏。

## CreateThread函数
msdn
系统从进程的地址空间中分配内存，供线程的堆栈使用。
系统从进程的地址空间中分配内存，供线程的堆栈使用。新线程运行的进程环境与创建线程
的环境相同。因此，新线程可以访问进程的内核对象的所有句柄、进程中的所有内存和在这个相
同的进程中的所有其他线程的堆栈。这使得单个进程中的多个线程确实能够非常容易地互相通信。

C r e a t e T h r e a d函数是用来创建线程的 Wi n d o w s函数。如果你正在编写
C / C + +代码，决不应该调用 C r e a t e T h r e a d。应该使用Visual C++运行期库函数
_ b e g i n t h r e a d e x。

p s a参数是指向S E C U R I T Y _ AT T R I B U T E S结构的指针。如果想要该线程内核对象的默认安
全属性，可以（并且通常能够）传递 N U L L。如果希望所有的子进程能够继承该线程对象的句
柄，必须设定一个S E C U R I T Y _ AT T R I B U T E S结构，它的b I n h e r i t H a n d l e成员被初始化为T R U E。（可以参考creatprocess的继承性）

c b S t a c k参数用于设定线程可以将多少地址空间用于它自己的堆栈
可以使用
链接程序的/ S TA C K开关来控制这个值：
r e s e r v e参数用于设定系统应该为线程堆栈保留的地址空间量。默认值是 1 MB
C o m m i t参
数用于设定开始时应该承诺用于堆栈保留区的物理存储器的容量。默认值是 1页。

当线程中的
代码执行时，可能需要多个页面的存储器。当线程溢出它的堆栈时，就生成一个异常条件（关
于线程堆栈和堆栈溢出的异常条件的详细说明，参见第 1 6章，关于一般异常条件的处理的详细
说明，参见第2 3章）。系统抓取该异常条件，并且将另一页（或者你为 c o m m i t参数设定的任何
值）用于保留空间，这使得线程的堆栈能够根据需要动态地扩大。（需要详细了解一下）

保留空间的容量用于为堆栈设置一个上限，这样就可以抓住代码中的循环递归错误。例如，
你编写一个递归自调用函数，该函数也包含导致循环递归的一个错误。每次函数调用自己的时候，
堆栈上就创建一个新的堆栈框。如果系统不设定堆栈的最大值，该递归函数就永远不会停止对自
己的调用。进程的所有地址空间将被分配，大量的物理存储器将被分配给该堆栈。通过设置一个
堆栈限制值，就可以防止应用程序用完大量的物理存储器，同时，也可以更快地知道何时程序中
出现了错误（*）

p f n S t a r t A d d r参数用于指明想要新线程执行的线程函数的地址。线程函数的 p v P a r a m参数与
原先传递给C r e a t e T h r e a d的p v P a r a m参数是相同的。

Wi n d o w s是个抢占式多线程系统，这意味着新线程和调用 C r e a t e T h r e a d的线程可以
同时执行。（*）

f d w C r e a t e参数可以设定用于控制创建线程的其他标志。主要控制线程创建后是否立即执行。

## 终止线程运行

### 线程函数返回
如果线程能够返回，就可以确保下列事项的实现：
• 在线程函数中创建的所有C + +对象均将通过它们的撤消函数正确地撤消。
• 操作系统将正确地释放线程堆栈使用的内存。
• 系统将线程的退出代码（在线程的内核对象中维护）设置为线程函数的返回值。
• 系统将递减线程内核对象的使用计数。

### ExitThread函数
该函数将终止线程的运行，并导致操作系统清除该线程使用的所有操作系统资源。但是，
C + +资源（如C + +类对象）将不被撤消。由于这个原因，最好从线程函数返回，而不是通过调
用E x i t T h r e a d来返回

如果编写C / C + +代码，
那么决不应该调用E x i t T h r e a d。应该使用Visual C++运行期库函数_ e n d t h r e a d e x。如果
不使用M i c r o s o f t的Visual C++编译器，你的编译器供应商有它自己的 E x i t T h r e a d的替
代函数。不管这个替代函数是什么，都必须使用

我们可以这么理解：windows创建/结束线程的函数可以确保windows资源被安全释放，但是如果是其他编译器，他们都有自己对应的函数，是在封装windows函数的基础上实现的，同时也包含了对应c/c++资源的初始化及释放，所以我们应该调用它们。

### Te r m i n a t e T h r e a d函数
与E x i t T h r e a d不同，E x i t T h r e a d总是撤消调用的线程，而Te r m i n a t e T h r e a d能够撤消任何线程。
h T h r e a d参数用于标识被终止运行的线程的句柄。当线程终止运行时，它的退出代码成为你作
为d w E x i t C o d e参数传递的值。同时，线程的内核对象的使用计数也被递减。

Te r m i n a t e T h r e a d函数是异步运行的函数，也就是说，它告诉系统你想要线程终
止运行，但是，当函数返回时，不能保证线程被撤消。

当使用返回或调用E x i t T h r e a d的方法撤消线程时，该线程的内存堆栈也被撤消。
但是，如果使用Te r m i n a t e T h r e a d，那么在拥有线程的进程终止运行之前，系统不撤消该
线程的堆栈。M i c r o s o f t故意用这种方法来实现Te r m i n a t e T h r e a d。如果其他仍然正在执行
的线程要引用强制撤消的线程堆栈上的值，那么其他的线程就会出现访问违规的问题。
如果将已经撤消的线程的堆栈留在内存中，那么其他线程就可以继续很好地运行。

## 线程终止时的操作
当线程终止运行时，会发生下列操作：
• 线程拥有的所有用户对象均被释放。在 Wi n d o w s中，大多数对象是由包含创建这些对象
的线程的进程拥有的。但是一个线程拥有两个用户对象，即窗口和挂钩。当线程终止运
行时，系统会自动撤消任何窗口，并且卸载线程创建的或安装的任何挂钩。其他对象只
有在拥有线程的进程终止运行时才被撤消。
• 线程的退出代码从S T I L L _ A C T I V E改为传递给E x i t T h r e a d或Te r m i n a t e T h r e a d的代码。
• 线程内核对象的状态变为已通知。
• 如果线程是进程中最后一个活动线程，系统也将进程视为已经终止运行。
• 线程内核对象的使用计数递减1。

一旦线程不再运行，系统中就没有别的线程能够处理该线程的句柄。然而别的线程可以调
用G e t E x i t c o d e T h r e a d来检查由h T h r e a d标识的线程是否已经终止运行

如果调用G e t E x i t C o d e T h r e a d时线程
尚未终止运行，该函数就用 S T I L L _ A C T I V E标识符（定义为0 x 1 0 3）填入D W O R D。如果该函
数运行成功，便返回 T R U E

## 线程内核对象的引用计数
该对象的初始使用计数是2（在线程停止运行和从C r e a t e T h r e a d返回的句柄关闭之前，线程
内核对象不会被撤消）。

一旦内核对象创建完成，系统就分配用于线程的堆栈的内存。该内存是从进程的地址空间
分配而来的，因为线程并不拥有它自己的地址空间。然后系统将两个值写入新线程的堆栈的上
端（线程堆栈总是从内存的高地址向低地址建立）。写入堆栈的第一个值是传递给C r e a t e T h r e a d
的p v P a r a m参数的值。紧靠它的下面是传递给C r e a t e T h r e a d的p f n S t a r t A d d r参数的值。

每个线程都有它自己的一组C P U寄存器，称为线程的上下文。该上下文反映了线程上次运
行时该线程的 C P U寄存器的状态。线程的这组 C P U寄存器保存在一个 C O N T E X T结构（在
Wi n N T. h头文件中作了定义）中。C O N T E X T结构本身则包含在线程的内核对象中。

指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器。记住，线程总是在进程
的上下文中运行的。因此，这些地址都用于标识拥有线程的进程地址空间中的内存。当线程的
内核对象被初始化时，C O N T E X T结构的堆栈指针寄存器被设置为线程堆栈上用来放置p f n S t a r t -
A d d r的地址。指令指针寄存器置为称为B a s e T h r e a d S t a r t的未文档化（和未输出）的函数的地址
中。该函数包含在K e r n e l 3 2 . d l l模块中（这也是实现C r e a t e T h r e a d函数的地方）

当线程完全初始化后，系统就要查看 C R E AT E _ S U S P E N D E D标志是否已经传递给
C r e a t e T h r e a d。如果该标志没有传递，系统便将线程的暂停计数递减为 0，该线程可以调度到一
个进程中。然后系统用上次保存在线程上下文中的值加载到实际的 C P U寄存器中。这时线程就
可以执行代码，并对它的进程的地址空间中的数据进行操作。

B a s e T h r e a d S t a r t（*） - startAttr . pvParam
由于新线程的指令指针被置为B a s e T h r e a d S t a r t，因此该函数实际上是线程开始执行的地方
新线程只是在此处产生并且开始执行
之所以可以访问这些参数，是因
为操作系统将值显式写入了线程的堆栈（这就是参数通常传递给函数的方法）。

当新线程执行B a s e T h r e a d S t a r t函数时，将会出现下列情况：
• 在线程函数中建立一个结构化异常处理（S E H）帧，这样，在线程执行时产生的任何异常情
况都会得到系统的某种默认处理（关于结构化异常处理的详细说明参见第2 3、2 4和2 5章）。
• 系统调用线程函数，并将你传递给C r e a t e T h r e a d函数的p v P a r a m参数传递给它。
• 当线程函数返回时，B a s e T h r e a d S t a r t调用E x i t T h r e a d，并将线程函数的返回值传递给它。
该线程内核对象的使用计数被递减，线程停止执行。
• 如果线程产生一个没有处理的异常条件，由B a s e T h r e a d S t a r t函数建立的S E H帧将负责处理
该异常条件。通常情况下，这意味着向用户显示一个消息框，并且在用户撤消该消息框时，
BzsethreadStart调用ExitThread，以终止整个进程的运行，而不只是终止线程的运行。

B a s e P r o c e s s S t a r t

另外，由于使用B a s e T h r e a d S t a r t，线程函数可以在它完成处理后返回。当 B a s e T h r e a d S t a r t
调用线程函数时，它会把返回地址推进堆栈，这样，线程函数就能知道在何处返回。但是，
B a s e T h r e a d S t a r t不允许返回。如果它不强制撤消线程，而只是试图返回，那么几乎可以肯定会
引发访问违规，因为线程堆栈上不存在返回地址，并且 B a s e T h r e a d S t a r t将试图返回到某个随机
内存位置。(?)

个人认为：B a s e T h r e a d S t a r t可能并没有存储在线程堆栈上，而是在一个固定的地址。

如果调用C r e a t e T h r e a d，而不是调用C / C + +运行期库的_ b e g i n t h r e a d e x来创
建新线程，将会发生什么情况。
首先，如果线程使用 C / C + +运行期库的s i g n a l函数，那么整个进程就会终止运行，因为
结构化异常处理帧尚未准备好。第二，如果不是调用 _ e n d t h r e a d e x来终止线程的运行，那么数
据块就不会被撤消，内存泄漏就会出现
创建这两个函数的目的是用来执行_ b e g i n t h r e a d e x和_ e n d t h r e a d e x函数的功能。但是，如你
所见，_ b e g i n t h r e a d函数的参数比较少，因此比特性全面的_ b e g i n t h r e a d e x函数受到更大的限制。
例如，如果使用_ b e g i n t h r e a d，就无法创建带有安全属性的新线程，无法创建暂停的线程，也
无法获得线程的I D值。_ e n d t h r e a d函数的情况与之类似。它不带参数，这意味着线程的退出代
码必须硬编码为0。

getCurrentProcess/thread handle

创建这两个函数的目的是用来执行_ b e g i n t h r e a d e x和_ e n d t h r e a d e x函数的功能。但是，如你
所见，_ b e g i n t h r e a d函数的参数比较少，因此比特性全面的_ b e g i n t h r e a d e x函数受到更大的限制。
例如，如果使用_ b e g i n t h r e a d，就无法创建带有安全属性的新线程，无法创建暂停的线程，也
无法获得线程的I D值。_ e n d t h r e a d函数的情况与之类似。它不带参数，这意味着线程的退出代
码必须硬编码为0。

当调用一个需要进程句柄或线程句柄的 Wi n d o w s函数时，可以传递一个伪句柄，使该函数
执行它对调用进程或线程的操作。

有时可能需要获得线程的实句柄而不是它的伪句柄。所谓“实句柄”，我是指用来明确标
识一个独一无二的线程的句柄

出现这种情况的原因是线程的伪句柄是当前线程的句柄，也就是说，它是调
用函数的线程的句柄。(即使从一个线程传入另一个线程，获得伪句柄仍是当前线程的伪句柄)

由于D u p l i c a t e H a n d l e会递增特定对象的使用计数，因此当完成对复制对象句柄的使用时，
应该将目标句柄传递给 C l o s e H a n d l e，从而递减对象的使用计数，这一点很重要。（*）





















































