# 线程

## 线程的构成

&emsp;&emsp;线程也是由两个部分组成的：

- 一个是线程的内核对象，操作系统用它来对线程实施管理。内核对象也是系统用来存放线程统计信息的地方。
- 另一个是线程堆栈，它用于维护线程在执行代码时需要的所有函数参数和局部变量。

## 进程与线程的区别

- 进程是不活泼的。进程从来不执行任何东西，它只是线程的容器。
- 进程使用的系统资源比线程多得多，原因是它需要更多的地址空间。为进程创建一个虚拟地址空间需要许多系统资源。exe、dll 需要加载到进程的地址空间;而线程只有一个内核对象和一个堆栈，保留的记录很少，因此需要很少的内存。

## 线程内核对象的安全计数

&emsp;&emsp;和进程类似，当线程创建时，内核创建线程使线程内核对象的安全计数+1；同时，创建线程的进程获得线程内核对象句柄，使线程内核对象的安全计数+1;所以，如果我们想要线程在终止时自动释放内核对象，需要在进程中调用 closehandle 关闭内核对象，从而使线程内核对象安全计数-1，这样当线程结束时，线程内核对象句柄将自动释放。

## 线程函数的安全

&emsp;&emsp;线程函数应该尽可能使用函数参数和局部变量。当使用静态变量和全局变量时，多个线程可以同时访问这些变量，这可能破坏变量的内容。然而，参数和局部变量是在线程堆栈中创建的，因此它们不太可能被另一个线程破坏。

## CreateThread 函数

&emsp;&emsp;系统从进程的地址空间中分配内存，供线程的堆栈使用。新线程运行的进程环境与创建线程的环境相同。因此，新线程可以访问进程的内核对象的所有句柄、进程中的所有内存和在这个相同的进程中的所有其他线程的堆栈。这使得单个进程中的多个线程确实能够非常容易地互相通信。

Windows 中用 CreateThread 函数来创建线程：

```cpp
HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  [in]            SIZE_T                  dwStackSize,
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,
  [in]            DWORD                   dwCreationFlags,
  [out, optional] LPDWORD                 lpThreadId
);
```

&emsp;&emsp;lpThreadAttributes 参数是指向 LPSECURITY_ATTRIBUTES 结构的指针。如果想要该线程内核对象的默认安全属性，可以（并且通常能够）传递 NULL。如果希望所有的子进程能够继承该线程对象的句柄，必须设定一个 LPSECURITY_ATTRIBUTES 结构，它的 bInheritHandle 成员被初始化为 TRUE。

&emsp;&emsp;dwStackSize 参数用于设定线程的初始化堆栈大小，如果设置为 0，新线程将使用默认值。该值可以在链接器》系统中进行设置。

&emsp;&emsp;线程的堆栈大小并不是保持在初始化大小不变的，而是会随着需要而增长，但是系统也为线程设置了一个保留堆栈大小的上限，保这样就可以抓住代码中的循环递归错误。例如，你编写一个递归自调用函数，该函数也包含导致循环递归的一个错误。每次函数调用自己的时候，堆栈上就创建一个新的堆栈框。如果系统不设定堆栈的最大值，该递归函数就永远不会停止对自己的调用。进程的所有地址空间将被分配，大量的物理存储器将被分配给该堆栈。通过设置一个堆栈限制值，就可以防止应用程序用完大量的物理存储器，同时，也可以更快地知道何时程序中出现了错误。

&emsp;&emsp;lpStartAddress 参数用于指明想要新线程执行的线程函数的地址，lpParameter 则是线程函数的启动参数。  
&emsp;&emsp;其中，线程函数的函数指针定义如下：

```cpp
typedef DWORD (WINAPI *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
```

&emsp;&emsp;dwCreationFlags 参数可以设定用于控制创建线程的其他标志。比如我们可以设置线程创建后是否立即执行。

&emsp;&emsp;需要注意的是：对于不同的软件框架，我们应当使用对应版本的线程启动函数，例如：如果你正在编写 C/C++代码，决不应该调用 CreateThread，而应该使用 Visual C++运行期库函数\_beginthradex。  
我们可以这样理解：\_beginthradex 在启动线程时，会为线程进行 C/C++资源的初始化，而 CreateThread 只会进行 Windows 资源的初始化，为了更好地进行线程运行，调用对应版本的线程启动函数(包括终止函数)是一个很好的选择。

&emsp;&emsp;lpThreadId 用于保存线程 ID，也可以传 NULL，那么线程 ID 将不会返回。

&emsp;&emsp;代码示例：

```cpp
DWORD WINAPI threadStart(LPVOID param)
{
    for (int i = 0 ; i < 10 ; ++i)
    {
        std::cout << "count = " << i << std::endl;
    }

    return 10;
}

...

CreateThread(NULL, 0, threadStart, (LPVOID)8, 0, NULL);
```

## 终止线程运行

### 线程函数返回

&emsp;&emsp;如果线程能够返回，就可以确保下列事项的实现：

- 在线程函数中创建的所有 C++对象均将通过它们的撤消函数正确地撤消。
- 操作系统将正确地释放线程堆栈使用的内存。
- 系统将线程的退出代码（在线程的内核对象中维护）设置为线程函数的返回值。
- 系统将递减线程内核对象的使用计数。

### ExitThread 函数

&emsp;&emsp;该函数将终止线程的运行，并导致操作系统清除该线程使用的所有操作系统资源。但是，C++资源（如 C++类对象）将不被撤消。由于这个原因，最好从线程函数返回，而不是通过调用 ExitThread 来返回

&emsp;&emsp;正如前文所述：如果编写 C/C++代码，那么决不应该调用 ExitThread。应该使用 Visual C++运行期库函数\_endthreadex。如果不使用 M i c r o s o f t 的 Visual C++编译器，你的编译器供应商有它自己的 ExitThread 替代函数。不管这个替代函数是什么，都必须使用。

### TerminateThread 函数

&emsp;&emsp;与 ExitThread 不同，ExitThread 总是撤消调用的线程，而 TerminateThread 能够撤消任何线程，只要直到该线程句柄。

&emsp;&emsp;TerminateThread 函数是异步运行的函数，也就是说，它告诉系统你想要线程终止运行，但是，当函数返回时，不能保证线程被撤消。

&emsp;&emsp;当使用返回或调用 ExitThread 的方法撤消线程时，该线程的内存堆栈也被撤消。但是，如果使用 TerminateThread，那么在拥有线程的进程终止运行之前，系统不撤消该线程的堆栈。Microsoft 故意用这种方法来实现 TerminateThread。如果其他仍然正在执行的线程要引用强制撤消的线程堆栈上的值，那么其他的线程就会出现访问违规的问题。如果将已经撤消的线程的堆栈留在内存中，那么其他线程就可以继续很好地运行。

## 线程终止时的操作

&emsp;&emsp;当线程终止运行时，会发生下列操作：

- 线程拥有的所有用户对象均被释放。在 Windows 中，大多数对象是由包含创建这些对象的线程的进程拥的。但是一个线程拥有两个用户对象，即窗口和挂钩。当线程终止运行时，系统会自动撤消任何窗口，并卸载线程创建的或安装的任何挂钩。其他对象只有在拥有线程的进程终止运行时才被撤消。
- 线程的退出代码从 STILL_ACTIVE 改为传递给 ExitThread 或 TerminateThread 的代码。
- 线程内核对象的状态变为已通知。
- 如果线程是进程中最后一个活动线程，系统也将进程视为已经终止运行。
- 线程内核对象的使用计数递减 1。

&emsp;&emsp;一旦线程不再运行，系统中就没有别的线程能够处理该线程的句柄。然而别的线程可以调用 GetExitcodeThread 来检查由 hThread 标识的线程是否已经终止运行，如果线程还未停止，那么返回 STILL_ACTIVE，否则返回线程退出码。

## 线程详解

![线程的创建](https://img-blog.csdnimg.cn/36f3d753b2d34d93af72131af05462aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOe576a,size_20,color_FFFFFF,t_70,g_se,x_16)

### 线程堆栈

&emsp;&emsp;系统创建线程完成后，会将两个值写入新线程的堆栈的上端（线程堆栈总是从内存的高地址向低地址建立）。写入堆栈的第一个值是线程函数参数，一个是线程函数地址。

### 上下文

&emsp;&emsp;每个线程都有它自己的一组 CPU 寄存器，称为线程的上下文。该上下文反映了线程上次运行时该线程的 CPU 寄存器的状态，该结构本身则包含在线程的内核对象中。

&emsp;&emsp;记住，线程总是在进程的上下文中运行的。因此，这些地址都用于标识拥有线程的进程地址空间中的内存。

&emsp;&emsp;指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器。当线程的内核对象被初始化时，CONTEXT 结构的堆栈指针寄存器被设置为线程堆栈上用来放置线程函数的地址。指令指针寄存器存放 BaseThreadStart 的函数的地址。该函数包含在 Kernel32.dll 模块中，该函数是 CreateThread 开始的地方。

&emsp;&emsp;BaseThreadStart 函数原型如下：

```
VOID BaseThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam)
{
  __try {
    ExitThread((pfnStartAddr)(pvParam));
  }
  __except(UnhandExceptionFilter(GetExceptionInformation())){
    ExitProcess(GetExceptionCode());
  }
}
```

&emsp;&emsp;由于新线程的指令指针被置为 BaseThreadStart，因此该函数实际上是线程开始执行的地方新线程只是在此处产生并且开始执行之所以可以访问这些参数，是因为操作系统将值显式写入了线程的堆栈。

&emsp;&emsp;从函数可以看出：BaseThreadStart 将会调用线程函数，并在线程函数结束后调用 ExitThread 结束线程。

### 暂停计数

&emsp;&emsp;CREATE_SUSPENDED 标志。如果已经传递了这个标志，那么这些函数就返回，同时新线程处于暂停状态。如果尚未传递该标志，那么该函数将线程的暂停计数递减为 0。当线程的暂停计数是 0 的时候，除非线程正在等待其他某种事情的发生，否则该线程就处于可调度状态。

&emsp;&emsp;通过 SuspendThread 可以使暂停计数+1（也包括创建线程时传入 CREATE\_ SUSPENDED 标志），调用 ResumeThread 使暂停计数-1，单个线程可以暂停若干次，但是暂停次数比如与恢复次数相等。

&emsp;&emsp;调用 SuspendThread 时必须小心，因为不知道暂停线程运行时它在进行什么操作。如果线程试图从堆栈中分配内存，那么该线程将在该堆栈上设置一个锁。当其他线程试图访问该堆栈时，这些线程的访问就被停止，直到第一个线程恢复运行。只有确切知道目标线程是什么（或者目标线程正在做什么），并且采取强有力的措施来避免因暂停线程的运行而带来的问题或死锁状态，SuspendThread 才是安全的。

## 伪句柄

&emsp;&emsp;当调用一个需要进程句柄或线程句柄的 Windows 函数时，可以传递一个伪句柄，使该函数执行它对调用进程或线程的操作。相关函数是 GetCurrentProcess、GetCurrentThread。需要注意的是：伪句柄获取的句柄，是当前线程的句柄，比如我们把一个伪句柄从一个线程传入另一个线程，那么该伪句柄是被传入线程的句柄。

&emsp;&emsp;有时可能需要获得线程的实句柄而不是它的伪句柄。所谓“实句柄”，我是指用来明确标识一个独一无二的线程的句柄。我们可以使用 DuplicateHandle 将伪句柄转换为实句柄。

&emsp;&emsp;由于 DuplicateHandle 会递增特定对象的使用计数，因此当完成对复制对象句柄的使用时，应该将目标句柄传递给 CloseHandle，从而递减对象的使用计数，这一点很重要。

## 上下文转换

&emsp;&emsp;每隔 20ms 左右，Windows 要查看当前存在的所有线程内核对象。在这些对象中，只有某些对象被视为可以调度的对象。Windows 选择可调度的线程内核对象中的一个，获取其内核对象中上下文寄存器的状态，将它加载到 CPU 的寄存器中。这项操作称为上下文转换。当线程结束时，又会把 CPU 寄存器状态保存到线程上下文的寄存器中，直到下次运行。

## 抢占式操作系统

&emsp;&emsp;Windows 被称为抢占式多线程操作系统，即系统只调度可以调度的线程，但是实际情况是，系统中的大多数线程是不可调度的线程。例如，NotePad 线程对象的暂停计数大于 1，但是并不键入任何数据，那么 Notepad 的线程就没有什么事情要做。系统不给无事可做的线程分配 CPU 时间。

## 线程休眠

&emsp;&emsp;调用 slepp，将会使线程放弃它剩余的时间片。

- 如果参数是 INFINITE，那么告诉系统永远不要调度该线程。
- 如果参数是 0，这将告诉系统，调用线程将释放剩余的时间片，并迫使系统调度另一个线程。但是，系统可以对刚刚调用 Sleep 的线程重新调度。
- 如果是非 0 值，那么线程将在这段时间内不被调用，但由于 Windows 操作系统是一个抢占式操作系统，所以操作系统并不一定会在规定的这个时间后被立即唤醒。

## 转换到另一个线程

&emsp;&emsp;当调用 SwitchToThread 时，如果存在其他可调度的线程，那么该线程将会被调度执行，即使该线程优先级比当前线程低。

&emsp;&emsp;调用 SwitchToThread 函数与调用 Sleep 是相似的，并且传递给它一个 0 m s 的超时。差别是 SwitchToThread 允许优先级较低的线程运行。即使低优先级线程迫切需要 CPU 时间，Sleep 也能够立即对调用线程重新进行调度。也就是说：如果 sleep，那么低优先级的线程很可能无法被调度，而前者则可以确保低优先级线程被调度。

## 线程的优先级

&emsp;&emsp;只要优先级为 31 的线程是可调度的，系统就绝对不会将优先级为 0 到 30 的线程分配给 CPU。这种情况称为渴求调度。这种优先级我们可以理解为是绝对优先级。

&emsp;&emsp;那么是否低优先级的线程将永远无法执行呢？并不是，大多数线程是不能调度的，即使高优先级线程，当其发现没有工作需要运行时，也会暂停处于不可调度状态，直到某些操作使其恢复到可调度状态，在此期间其他线程运行。

&emsp;&emsp;高优先级线程将抢在低优先级线程之前运行，不管低优先级线程正在运行什么。例如，如果一个优先级为 5 的线程正在运行，系统发现一个高优先级的线程准备要运行，那么系统就会立即暂停低优先级线程的运行（即使它处于它的时间片中），并且将 CPU 分配给高优先级线程，使它获得一个完整的时间片。

&emsp;&emsp;需要注意的是，随着系统用途的变化，线程调度算法是不断变化的。

&emsp;&emsp;需要注意的是：进程也有优先级，可以通过 SetPriorityClass 来设置进程的优先级，进程是根本不能调度的，只有线程才能被调度。进程优先级类是个抽象概念，Microsoft 提出这个概念的目的，是为了帮助我们将它与调度程序的内部运行情况区分开来。

&emsp;&emsp;线程的优先级是由进程优先级和线程优先级共同决定的，正常进程中的正常线程被赋予的优先级是 8。由于大多数进程属于正常优先级类，而大多数线程属于正常线程优先级，因此系统中的大多数线程的优先级是 8。如果高优先级进程中有一个正常线程，该线程的优先级将是 13。

## 优先级类

&emsp;&emsp;Windows 支持 6 个优先级类：即空闲、低于正常、正常、高于正常、高和实时。当然，正常优先级是最常用的优先级类，这种优先级由 0~31 映射而来。我们可以理解为相对优先级。

&emsp;&emsp;我们无法直接设置绝对优先级，但是却可以设置相对优先级。

&emsp;&emsp;一般来说，大多数时候高优先级的线程不应该处于可调度状态。当线程要进行某种操作时，它能迅速获得 CPU 时间。这时线程应该尽可能少地执行 CPU 指令，并返回睡眠状态，等待再次变成可调度状态。相反，低优先级的线程可以保持可调度状态，执行大量的 CPU 指令来进行它的操作。如果按照这些原则来办，整个操作系统就能正确地对用户作出响应。

![优先级类](https://img-blog.csdnimg.cn/d024dbb52daa483faec88301930ea956.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6aOe576a,size_20,color_FFFFFF,t_70,g_se,x_16)

## 线程优先级的动态调度

&emsp;&emsp;系统为了达到最佳性能会对线程的优先级进行动态设置，比如当一个正常优先级的线程（13）消息队列中被放入 key 消息时，将会进入调度，优先级将会提高，然后逐步恢复正常。但线程的当前优先级等级决不会低于线程的基本优先级等级。

&emsp;&emsp;用户对进程的窗口进行操作时，该进程就称为前台进程，所有其他进程则称为后台进程。当然，用户希望他正在使用的进程比后台进程具有更强的响应性。为了提高前台进程的响应性，Windows 能够为前台进程中的线程调整其调度算法。对于 Windows 2000 来说，系统可以为前台进程的线程提供比通常多的 CPU 时间量。这种调整只能在前台进程属于正常优先级类的进程时才能进行。如果它属于其他任何优先级类，就无法进行任何调整。

## 线程能否执行

&emsp;&emsp;根据上文所述，可以总结得出一个线程能够执行取决于以下条件：

- 是否被暂停，被暂停的进程不参与调度；
- 该线程是否有事可做，如果无事可做，系统通常让它处于不可调度状态，直到某一条件触发，比如键盘输入；
- 该线程的优先级，当上述两个条件都满足时，该线程参与调度，但其优先级决定了它是否能够被调度执行；
